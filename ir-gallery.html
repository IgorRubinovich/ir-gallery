<link rel="import" href="../paper-dialog/paper-dialog.html">
<link rel="import" href="../rv-iscroll/rv-iscroll.html">
<link rel="import" href="../paper-material/paper-material.html">
<link rel="import" href="../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../iron-media-query/iron-media-query.html">
<link rel="import" href="../neon-animation/neon-animation.html">
<link rel="import" href="../iron-image/iron-image.html">
<link rel="import" href="../paper-radio-group/paper-radio-group.html">
<link rel="import" href="../paper-menu/paper-menu.html">
<link rel="import" href="../iron-icons/iron-icons.html">
<!-- link rel="import" href="ir-gallery-style.html" -->

<script rel="import" src="../iscroll/build/iscroll.js"></script>
<script src="../css-element-queries/src/ResizeSensor.js"></script>

<dom-module id="ir-gallery">
	<style> 
		:host {
			overflow : hidden
		}
		
		#contentNode { display : none }
		
		.viewPort {
			height :600px;
			width : 400px;
			overflow : hidden;
			margin : 0;
			padding : 0;
			background : transparent;
		}

		.wrapper {
			position: relative;

			overflow: hidden;

			/* Prevent native touch events on Windows */
			-ms-touch-action: none;

			/* Prevent the callout on tap-hold and text selection */
			-webkit-touch-callout: none;
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;

			/* Prevent text resize on orientation change, useful for web-apps */
			-webkit-text-size-adjust: none;
			-moz-text-size-adjust: none;
			-ms-text-size-adjust: none;
			-o-text-size-adjust: none;
			text-size-adjust: none;
		}
		
		.wrapper.main,.main {
			width: 100%;
			height : 500px;
			padding : 0;
		}
		.wrapper.thumbnails, .thumbnails {
			padding : 0;
		}
		
		.thumbnails {
			cursor : pointer
		}

		.main iron-image {
			width : 200px
		}
		.scroller iron-image {
			width : 200px
		}
		
		.scroller {
			abackground-color : #ddee00;
			position: absolute;

			/* Prevent elements to be highlighted on tap */
			-webkit-tap-highlight-color: rgba(0,0,0,0);

			/* Put the scroller into the HW Compositing layer right from the start */
			-webkit-transform: translateZ(0);
			-moz-transform: translateZ(0);
			-ms-transform: translateZ(0);
			-o-transform: translateZ(0);
			transform: translateZ(0);
			
			/*width : 600px;
			height : 200px;*/
		
			display : flex;
			left : 0;
		}
		
		figure {
			margin : 0 auto auto;
		}
		figcaption {
		}		

		.slide {
			/*float: left;*/
			/*border : 1px solid red;*/
			@apply(--slide-mixin)
		}
		
		paper-dialog {
			background : transparent;
			overflow : hidden;
			position : fixed;
			left : 0;
			top : 0;
			bottom : 0;
			right 0;
		}
		
		.wrapper {
		}
	</style>
	<template>
		<div id="container">
			<div class="viewPort" id="inlineContainer"></div>
			<paper-dialog id="dialog" with-backdrop><div class="viewPort" id="dialogContainer"></div></paper-dialog>
			<div id="contentNode"><content></content></div>
		</div>
	</template>

</dom-module>


<dom-module id="ir-gallery-echo-html">

  <template>
	<span id="content"></span>
  </template>

  <script>
	Polymer({
	  is: 'ir-gallery-echo-html',
	  properties: {
		  html: {
			  type: String,
			  value: '',
			  observer : 'htmlChanged'
		  }
	  },
		htmlChanged: function() {
		this.$.content.innerHTML = this.html;
		  //this.innerHTML = this.html;
	  }
	});
  </script>

</dom-module>

<dom-module id="ir-gallery-theme">
	<template>
	  <content id="templates"></content>
	</template>
</dom-module>

<script>
(function() {
  "use strict";

  var themes  = {};

  Polymer({
	is : "ir-gallery-theme",

	properties : {
	  templateItem :  { type : Object, notify : true },
	  name :		  { type : String, notify : true }
	},

	behaviors : [
	  Polymer.Templatizer
	],

	attached : function() {

	  var templates = Polymer.dom(this.$.templates).getDistributedNodes(),
		  inlineTemplate,
		  dialogTemplate;
	  	  
	  for(var i = 0; i < templates.length; i++)
		if(templates[i].tagName == "TEMPLATE")
		  if(templates[i].hasAttribute('inline'))
			inlineTemplate = templates[i];
		  else
			if(templates[i].hasAttribute('dialog'))
			  dialogTemplate = templates[i];   

	  inlineTemplate.className = "";
	  dialogTemplate.className = "";

	  themes[this.name] = { inline : inlineTemplate, dialog : dialogTemplate, name : this.name };

	  this.fire('ir-gallery-theme-ready', { inline : inlineTemplate, dialog : dialogTemplate, name : this.name });
	}
  });
  
  function dimensionsData() {
	return {
		width : 0,
		height : 0
	}
  }
  
  function displayAreaData(areaName, sectionName) {
	return {
				name : areaName,
				section : sectionName,
				slides : [],
				captions : [],
				scroller : null,
				wrapper : null,
				dimensions : {
					wrapper : dimensionsData(),
					slide : dimensionsData(),
					scroller : dimensionsData(),
				}
			}
  }
  
  function sectionData(sectioName) {
	return {
		name : sectioName,
		template : null,
		dimensions : dimensionsData(),
		displayAreas : {
			main 		: displayAreaData('main', sectioName),
			thumbnails 	: displayAreaData('thumbnails', sectioName),
		}
	}
  }
  
  function sectionsDataStore() {
	return {
		inline : sectionData('inline'),
		dialog : sectionData('dialog')
	}
  }
  
  Polymer({
			is : 'ir-gallery',

			properties : {
				images  		: 	{ type : Array, value : function() { return [] } },
				theme 			:	{ type : String, notify : true, value : "default" },
				themes 			: 	{ type : Object, value : themes },
				ratio 			: 	{ type : Number, value : .8 },
				currentPage 	: 	{ type : Number, value : 0 },
				sectionsData 	: 	{ type : Object, value : sectionsDataStore },
			},
			
			behaviors : [
				Polymer.Templatizer
			],

			ready : function () {
			},
			
			attached : function () {
				this.resetDimensions();
				
				this.clearScrollers();
				this.scanForImages();

				this.applyTheme(function() {				
					this.fillAndFit('inline');
					
					this.async(function() {
						// observe resize
						new ResizeSensor(this.offsetParent, function() {
							this.debounce('ResizeSensor', this.refit, 300);
						}.bind(this))
					});
				}.bind(this));
				
				
				
				
				return;

				// observe nodes
				Polymer.dom(this.$.contentNode).observeNodes(function(info) {
					this.clearScrollers();
					this.scanForImages();
					this.init();
				}.bind(this))
			},
			
			// fits the section into its container and fills out images&scrollers
			fillAndFit : function(sectionName) {
				this.fitSectionContent(sectionName);
				this.fillSectionContent(sectionName);
				this.styleSectionContent(sectionName);

				this.assignCommands(this.sectionsData[sectionName].container);
				
				//Polymer.dom(da.scroller).appendChild(slide);
				// this.fill(sectionName);
			},
			
			refit : function() {
				this.resetDimensions.call(this);
				this.fitSectionContent('inline');
				this.styleSectionContent('inline');
			},
			
			resetDimensions : function() {
				this.forEachDisplayArea(function(da) {
					Object.keys(da.dimensions).forEach(function(da, type) {
						da.dimensions[type] = dimensionsData();
					}.bind(this, da))
				}); 
			},

			// styles section content in a non-destructive manner
			styleSectionContent : function(sectionName) {
				this.forEachDisplayArea(function(da) {
					var capSize, size = da.dimensions.slide;

					this.scopeSubtree(da.wrapper, true);

					da.slides.forEach(function(slideData) {

						this.setSize(slideData.slide, size);
						this.setSize(slideData.wrapper, size);

						if(!slideData.caption)
							this.setSize(slideData.image, size);
						else
						{
							this.setSize(slideData.image, { width : size.width, height : size.height * this.ratio });
							this.setSize(slideData.caption, { width : size.width, height : size.height * (1 - this.ratio) });
						}
					}.bind(this));
				}.bind(this), sectionName);
			},

			
			// fills section into container or dimensions given in its css
			fillSectionContent : function(sectionName) {
				this.forEachDisplayArea(function(da) {
					console.log('filling ', da.name)
					this.populateDisplayArea(da);
					this.populateSlides(da);
					this.upgradeScroller(da);
				}.bind(this), sectionName); 
			},
			
			// fits section into container or dimensions given in its css
			fitSectionContent : function(sectionName) {
				var container, minh, minw, fminh, fminw, t, bcr,
					dialogMode = sectionName == 'dialog', takesh, takesw;
				
				container = this.$[sectionName + "Container"];
				
				minh = Infinity; //this.dimensions[sectionName].refit.height;
				minw = Infinity;
				
				fminh = function(val) { minh = Math.min(minh, val) || val || minh } // these help us see the trees behind the forest
				fminw = function(val) { minw = Math.min(minw, val) || val || minw }
				
				if(!dialogMode)
				{
					fminh(this.style.height && this.style.height.replace(/px/, ''));
					fminw(this.style.width && this.style.width.replace(/px/, ''));
				}
				
				fminh(document.body.clientHeight);
				fminw(document.body.clientWidth);

				t = container.offsetParent;
				
				do {
					bcr = t.getBoundingClientRect();
					fminw(bcr.width);
					fminh(bcr.height)
					fminw(t.clientWidth)
					fminh(t.clientHeight)
					t = t.offsetParent;
				} while(t);
				
				this.forEachDisplayArea(function(da) {
					if(da.wrapper)
						da.wrapper.style.height = 0;
				});
				
				container.style.height = 0;
				container.style.width = 0;
				
				takesh = container.scrollHeight
				takesw = container.scrollWidth
			
				container.style.height = minh;
				container.style.width = minw;
				
				this.forEachDisplayArea(function(da) {
					da.wrapper.style.width = minw;
						da.dimensions.wrapper.width = minw;
					
					da.wrapper.style.height = 
						da.dimensions.wrapper.height = (minh -takesh) * (da.name == 'main' ? this.ratio : 1 - this.ratio);
				
					da.dimensions.slide.height = da.dimensions.wrapper.height;
					da.dimensions.slide.width = da.name == 'main' ? minw : da.dimensions.slide.height * (minh / minw); 
				}.bind(this), sectionName);
			},
			
			x_refit : function(section) {
				// this.$.container.style.visibility = "hidden";
				this.debounce('refit', function() {
					var cont = this.$[section + "Container"],
						hNeedsRefit = this.dimensions[section].wanted.height < cont.scrollHeight;
					
					this.dimensions[section].refit.height = 2 * this.dimensions[section].wanted.height - cont.scrollHeight;

					console.log('needs refit: ', hNeedsRefit, 'container height: ', cont.scrollHeight, "should refit content to", this.dimensions[section].refit.height);
					
					//console.log("height did fit: ", hNeedsRefit);
					//this._refitHeight = 2 * this._height - cont.scrollHeight;
					//this._refitWidth = 2 * this._width - cont.scrollWidth;
	
					if(hNeedsRefit)
						this.init(section);
					else
					{
						this.debounce('visibility' + section, function() {
							this.$.container.style.visibility = "visible";
						}, 100);
					}
				}.bind(this), 100);
			},
			
			init : function(section) {
				var initialized, apply;
				
				return;
				
				if(!section)
					section = 'inline';
				
				//this.$.container.style.visibility = "hidden";
				
			},

			clearAll : function(filter) {
				this.clearScrollers(filter);
				if(!filter || filter == 'inline') Polymer.dom(this.$.inlineContainer).innerHTML = '';
				if(!filter || filter == 'dialog') Polymer.dom(this.$.dialogContainer).innerHTML = '';
				Polymer.dom.flush();
			},
			
			isCaptionWrapper : function(el) {
				return el.nodeName == 'FIGURE';
			},
			
			getCaptionHTML : function(el) {
				return Polymer.dom(Polymer.dom(el).querySelector('figcaption')).innerHTML;
			},
			
			getImageCaption : function(img) {
				var captionHolder, captonChildren = [];
				if(this.isCaptionWrapper(img.parentNode))
					return Polymer.dom(Polymer.dom(img.parentNode).querySelector('figcaption')).innerHTML;
					
				return;
			},
			
			scanForImages : function() {
				var imgs = Polymer.dom(this).querySelectorAll('img');
				
				this.images = [];
				
				imgs.forEach(function(img, i) {
					var imgData = 	{
										src : img.src, 
										captionHTML : this.getImageCaption(img), 
										index : i
									};
									
					this.images.push(imgData);
				}.bind(this));
			},
			
			/*
				apply theme to all sections of target, where target is 'inline' or 'dialog'
			*/
			applyTheme : function(callback) {
				var initialized, apply;
				
				apply = function() { 
					if(initialized)
						return;
					
					this._applyTheme('inline');
					initialized = true;
					
					if(callback)
						callback();

					return;
					
					if(this.$.dialog.opened)
					{
						this.async(function() {
							this._applyTheme('dialog', this.refit.bind(this, 'dialog'));
						}, 100);
					}
				}.bind(this);
				
				if(this.themes[this.theme])
					apply();
				else
				{
					document.addEventListener('ir-gallery-theme-ready', function(ev) {
						if(ev.detail.name == this.theme)
							apply(); //(themes[this.theme].inline, themes[this.theme].dialog, true);
					}.bind(this));

					// if nothing happened within 5 seconds the template is probably not available and we should use the default
					this.async(apply, 5000);
				}
			},
			
			_applyTheme : function(sectionName, callback) {				
				var instance, section;
				
				section = this.$[sectionName + "Container"];
				
				this.sectionsData[sectionName].template = this.themes[this.theme][sectionName]; // y?
				this.sectionsData[sectionName].container = section;
				
				instance = this.stampThemeSection(section, this.themes[this.theme][sectionName]);
				//this.debounce('applyTheme' + sectionName, function() {
					var sd = this.sectionsData[sectionName];
					sd.displayAreas.main.wrapper = Polymer.dom(section).querySelector('.main');
					sd.displayAreas.thumbnails.wrapper = Polymer.dom(section).querySelector('.thumbnails');
					//callback(instance);
					//this.section
				//}, 100)
			},
				
			styleThemeSection : function() {
					var themeData = this.themes[this.theme],
						w, h, min, t, minw, minh, pic, stampRes,
						container, toStyle, hcmd, invratio, invratiosq, 
						cs, margins, bcr, fminh, fminw, opts;
					
					// calculate container size
					var dialogMode = sectionName == 'dialog';

					container = this.$[sectionName + "Container"];
					
					minh = this.dimensions[sectionName].refit.height;
					minw = Infinity;
					
					fminh = function(val) { minh = Math.min(minh, val) || val || minh } // these help us see the trees behind the forest
					fminw = function(val) { minw = Math.min(minw, val) || val || minw }
					
					if(!dialogMode)
					{
						fminh(this.style.height && this.style.height.replace(/px/, ''));
						fminw(this.style.width && this.style.width.replace(/px/, ''));
					}
					
					fminh(document.body.clientHeight);
					fminw(document.body.clientWidth);

					t = container.offsetParent;
					
					do {
						bcr = t.getBoundingClientRect();
						fminw(bcr.width);
						fminh(bcr.height)
						fminw(t.clientWidth)
						fminh(t.clientHeight)
						t = t.offsetParent;
					} while(t);
					
					min = Math.min(minw, minh);
					h = w = min;
					
					if(!this.dimensions[sectionName].wanted.height)
						this.dimensions[sectionName].wanted.height = h;
	
					this.scrollers[sectionName] = {};
					
					opts = { 
								section : sectionName, 
								size : min, 
								slideWidth : minw, 
								dialogMode : dialogMode 
							};
					
					this.stampThemeSection(container, themeData[sectionName], opts);

					return;
					this.populateThemeSection(container, opts)
					
					//dialog = this.stampThemeSection(this.$.dialogContainer, themeData.dialog, .35 * min);
					
					container.style.width = minw + 'px';
					container.style.height = this.dimensions[sectionName].wanted.height + 'px';
					
					pic = Polymer.dom(container);
					
					toStyle = {};
					toStyle.main = pic.querySelector('.main').style;
					toStyle.commands = pic.querySelector('.commands').style;
					toStyle.thumbnails = pic.querySelector('.thumbnails').style;
					
					if(this.images.length <= 1)
					{	
						t = Polymer.dom(pic).querySelectorAll('.commands')
							.forEach(function(t) { 
								Polymer.dom(Polymer.dom(t).parentNode).removeChild(t) 
							});
					}
					
					//this.setSizeToParentClientSize([pic.querySelector('.main'), pic.querySelector('.commands'), pic.querySelector('.main')])
					
					toStyle.main.width = toStyle.thumbnails.width = toStyle.commands.width = minw + "px";
					toStyle.main.height = (this.images.length > 1 ? this._ratio : 1) * h + "px";

					invratio = 1 - this._ratio;
					invratiosq = invratio * invratio;

					if(!dialogMode)
						Polymer.dom(this.root).querySelector('.viewPort').style.height = this._wantedHeight;
				
					if(callback)
						callback.call(this);
				//}.bind(this), 100);
			},
			
			nextPage : function(page) {
				var p = this.currentPage, 
					l = this.images.length - 1;
				
				p = p >= l ? 0 : p + 1; 
				this.goToPage(p);
			},
			prevPage : function(page) {
				if(this.images.length <= 1)
					return
				var p = this.currentPage, 
					l = this.images.length - 1;
				
				p = p <= 0 ? l : p - 1; 
				this.goToPage(p)
			},
			
			goToPage : function(page) {
				if(this.images.length <= 1)
					return
				this.currentPage = page;
				this.syncScrollers();
			},
			
			forEachSection : function(foo, sections) {
				if(!sections)
					sections = ['inline', 'dialog'];
				if(!(sections instanceof Array))
					sections = [sections];
					
				sections.forEach(function(s) { 
					foo(this.sectionsData[s]) 
				}.bind(this));
			},

			forEachDisplayArea : function(foo, section) {
				this.forEachSection(function(s) {
					Object.keys(s.displayAreas)
						.forEach(function(da) { 
							var q = s.displayAreas[da];
							if(q) 
								foo(q); 
						}.bind(this));
				}, section);
			},
			
			forEachScroller : function(foo) {
				this.forEachDisplayArea(function(da) {
					if(da.iscroll)
						foo(da.iscroll);
				});
			},
			
			// section is 'inline' or 'dialog'
			clearScrollers : function() {
				this.forEachScroller(function(s) { s.destroy(); });
			},
			
			syncScrollers : function() {
				/*var 
					alls = this.scrollers, 
					s = alls[section];
					
				this.currentPage = s[sourceScroller].currentPage.pageX || 0;
				*/
				
				this.forEachScroller(function(s) {
					s.goToPage(this.currentPage, 0); 
				}.bind(this));
			},
			
			/*
				stamp theme template into section
				returns template instance (Polymer.base)
			*/
			stampThemeSection : function(container, template) {
				var instance, t;
				t = template;		
				
				this.templatize(t);
				instance = this.stamp({});
				Polymer.dom(container).appendChild(instance.root);
				
				return instance;
			},
			
			upgradeScroller : function(da, callback)
			{
				this.async( function(target) {
					var scrollers = {};
					
					da.wrapper.style.position = 'relative'
					da.scroller.style.position = 'relative'
					da.scroller.style.width = da.dimensions.slide.width * this.images.length
					//da.wrapper.style.position = 'relative'; 
					da.wrapper.style.overflow = 'hidden'; 
					
					da.iscroll = new IScroll(da.wrapper, {
						mouseWheel: true,
						scrollX: this.images.length > 1,
						scrollY: false,
						momentum: true,
						snap: ".slide",
						snapSpeed: 500,
						keyBindings: da.name == 'dialog' && this.images.length > 1
					});
					
					da.iscroll.refresh();
				
					if(this.images.length > 1)
						da.iscroll.on('scrollEnd', function() { 
							this.cancelDebouncer('scrollEnd'); 
							this.debounce('scrollEnd', function() { 
								this.currentPage = da.iscroll.currentPage.pageX;
								this.syncScrollers();
							}.bind(this), 600);
						}.bind(this));
					
					if(callback) callback();
				}, 300);													
			},

			assignCommand : function(target, selector, foo)
			{
				var els = Polymer.dom(target).querySelectorAll(selector);
				els.forEach(function(el) {
					el.addEventListener('click', foo)
				}.bind(this));
			},
			
			assignCommands : function(target) {
				this.async(function() {
					var commandsEl = Polymer.dom(target).querySelectorAll('.commands');
					if(!commandsEl.length)
						return;
					//commandsEl.forEach(function() {
					this.assignCommand(target, '[command-forward]', this.nextPage.bind(this));
					this.assignCommand(target, '[command-backward]', this.prevPage.bind(this))
					this.assignCommand(target, '[command-close]', this.closeDialog.bind(this))
				},100)
				//}.bind(this))
			},

			closeDialog : function () {
				this.$.dialog.close();
			},
			openDialog : function ()
			{
				var size = Math.min(document.body.clientWidth, document.body.clientHeight);
				
				this.$.dialog.open();
				
				if(this.scrollers.dialog)
					return this.goToPage(this.currentPage);
					
				this.$.dialog.style.width = document.body.clientWidth;
				this.$.dialog.style.height = document.body.clientHeight;
				this.applyTheme('dialog', function() {
					this.refit('dialog');
					this.goToPage(this.currentPage)
				}.bind(this));
				
			},
			
			setSize : function(el, size)
			{
				if(typeof size != 'object')
					size = { height : size, width : size };
					
				el.style.width = size.width;
				el.style.height = size.height;
				
				return el;
			},
			
			setSizeToParentClientSize : function(nodes) 
			{
				if(!(nodes instanceof Array))
				{
					if(nodes.length)
						nodes = [].slice.call(nodes);
					else
						nodes = [nodes];
				}
				
				nodes.forEach(function(n) {
					n.width = n.parentOffset.clientWidth
					n.height = n.parentOffset.clientHeight
				});
			},
			
			// creates a slide from data. returns slideData
			slideFromData : function(imgData, opts, thumbsMode)
			{
				var wrapper, caption, tocenter, w, h, imgel, slide,
					hasCaption = imgData.captionHTML && !thumbsMode;

				imgel = document.createElement('iron-image');
				slide = document.createElement('div');
				slide.classList.add('slide');
				slide.style.position = 'relative';

				imgel.src = imgData.src;
				imgel.index = imgData.index;
				imgel.sizing = 'contain';
				imgel.style.width = opts.width
				imgel.style.height = opts.height

				wrapper = document.createElement('figure');					
				Polymer.dom(wrapper).appendChild(imgel);
				Polymer.dom(slide).appendChild(wrapper);

				if(hasCaption)
				{
					caption = document.createElement('figcaption');
					Polymer.dom(caption).innerHTML = imgData.captionHTML;				
					Polymer.dom(wrapper).appendChild(caption);
				}
				
				if(opts.onclick)
					slide.addEventListener("click", opts.onclick.bind(this));
			
				return { 
							slide : slide, 
							caption : caption, 
							wrapper : wrapper,
							image : imgel
						};
			},
			
			/* Populates slides into a display area */
			populateSlides : function(da) {
				var thumbMode = da.name == 'thumbnails';
				
				da.slides.forEach(function(slideData) {
					Polymer.dom(Polymer.dom(slideData.slide).parentNode).removeChild(slideData.slide);
				});
				
				da.slides = [];
				
				// add slides to scroller
				this.images.forEach(function(imgData) {
					var slideData = this.slideFromData(imgData, da.dimensions[thumbMode ? 'wrapper' : 'slide'], thumbMode);
					da.slides.push(slideData);
					Polymer.dom(da.scroller).appendChild(slideData.slide);
				}.bind(this));
			},
			
			styleSlides : function(da) {
				this.slides.forEach(function(slideData) {
					Polymer.dom(slideData.slide).classList.add('slide');
					//slideData.caption && Polymer.dom(slideData.caption).classList.add(this.themes[this.theme].scopeClass);

					w = opts.slideWidth || opts.size;
					h = opts.size * (hasCaption ? this._ratio * 1.3 : 1);

					caption.style.height  = opts.height * this.ratio;
					wrapper.style.height = h - caption.offsetHeight;
					imgel.style.height = h - caption.offsetHeight;
					
					this.setSize(slide, { width : w, height : h }); //* (opts.noCaption ? this._ratio : 1) });				
					this.setSize(imgel, { width : w, height : h }); //* (opts.noCaption ? this._ratio : 1) });				
					this.setSize(wrapper, { width : w, height : h});				

					slide.display = 'block';
					slide.style.textAlign = 'center';
				}.bind(this));
			},
			
			// populates a scroller/thumbnails container
			//
			// opts: selector, size, noCaption, onClick
			populateDisplayArea : function(da) {
				var scroller, pt, thumbMode;

				// build scroller
				
				// remember: wrapper -> scroller -> slides, and iScroll is initialized on wrapper
				Polymer.dom(da.wrapper).classList.add('wrapper');
				
				if(da.scroller)
					da.scroller.destroy();
				
				// create wrapper in scroller
				scroller = document.createElement('div');
				Polymer.dom(scroller).classList.add('scroller')

				Polymer.dom(da.wrapper).appendChild(scroller);

				scroller.style.width = da.dimensions.slide.width * da.slides.length; 
				scroller.style.height = da.dimensions.slide.height; 
				da.wrapper.style.position = 'relative'; 
				da.wrapper.style.overflow = 'hidden'; 
			
				da.scroller = scroller;
			
				Polymer.updateStyles();
			},
			
			goBack : function(e) {
			},

			goForward : function(e) {

			}, 

			keyNav : function(e) {
			  if(e.keyCode == 37)
			  {
				this.pageToSwap -= 1;
				if(this.pageToSwap < 0)
				  this.pageToSwap = this.images.length - 1;
				this.$['gallery-thumbnails'].scroll.prev();
				this.goToPage('gallery-scroller', this.pageToSwap);
				this.selectGalleryThumb(this.pageToSwap);
			  }
			  else
				if(e.keyCode == 39)
				{
				  this.pageToSwap += 1;
				  if(this.pageToSwap > (this.images.length - 1))
					this.pageToSwap = 0;
				  this.$['gallery-thumbnails'].scroll.next();
				  this.goToPage('gallery-scroller', this.pageToSwap);
				  this.selectGalleryThumb(this.pageToSwap);
				}
			},		  

		});
})();		
</script>
	


<dom-module id="ir-gallery-theme-defaults">
	<template>

	<!--textarea style="display : none;"-->
	  <ir-gallery-theme name="default"> 
		<template inline> 
			<style> 
				.main { display: flex; flex: 1; padding : 5px }
				.commands { display: flex; justify-content : space-between;}
				.slide { 
					border : 3px solid green;
				}
				.thumbnails { display : flex, align-items : middle}
				#inline-wrapper { background : #fafafa;  background : pink; margin-bottom : 2px }
			</style>
			<div id="inline-wrapper">
				<div class="main"></div> 
				<div class="commands"><paper-icon-button command-backward icon="chevron-left"></paper-icon-button><paper-icon-button command-forward icon="chevron-right"></paper-icon-button></div>
				<div class="thumbnails"></div>
			</div>
		</template> 
		<template dialog> 
		  <style>
			.main > * {
				display : block;
				border-style: solid; 
				border-radius: 8px; 
				border-color: #767676; 
				border-width: 4px; 
				box-shadow: 0 0 0 0; 
				padding : 10px;
				background : white;
			}
			.figure {
				display : flex;
				align-items: center;
				justify-content: center;
			}
			.canceldiv { text-align : right }
			#dialog-wrapper { position : relative; background : white; border : 3px grey solid; border-radius : 5px; }

		   </style> 
		  <div id="dialog-wrapper"> 
			<div class="main"></div>
			<div class="commands"><paper-icon-button command-backward icon="chevron-left"></paper-icon-button><paper-icon-button command-forward icon="chevron-right"></paper-icon-button></div>
			<div class="thumbnails"></div>
			<div class='canceldiv'><paper-icon-button command-close icon="cancel"></paper-icon-button></div>
		  </div> 
		</template>
	  </ir-gallery-theme> 
	  <ir-gallery-theme name="transparent"> 
		<template inline> 
		  <style>
			.main { display: flex; flex: 1;}
		  </style> 
		  <div class="main"></div> 
		  <div class="scroller"></div> 
		</template> 
		<template dialog> 
		  <style>
			.transparentBlock {display: flex; flex: 1; flex-direction: column;} .dmain { display: flex; flex: 1;}
		  </style>
		  <div class="transparentBlock"> 
			<div class="dmain"></div> 
			<div class="dscroller"></div> 
			<div style="text-align: right;"> 
			  <paper-icon-button id="cancelButton" icon="cancel"></paper-icon-button> 
			</div>
		  </div> 
		</template>
	  </ir-gallery-theme>
	<!--/textarea-->
  		
	</template>
</dom-module>


<script>
(function() {
  Polymer({
		is : "ir-gallery-theme-defaults",

		attached : function(e) {
			var templates = document.createElement('div');
			//templates.innerHTML = Polymer.dom(this.root).innerHTML;
			Polymer.dom(document.body).appendChild(this.root);
		}
	})

	// This might not suffice for some browsers but seems like everything after IE8 is fine.
	document.addEventListener("DOMContentLoaded", function() {
		Polymer.dom(document.body).appendChild(document.createElement("ir-gallery-theme-defaults"));
	});
  

})();
</script>