<link rel="import" href="../paper-dialog/paper-dialog.html">
<link rel="import" href="../rv-iscroll/rv-iscroll.html">
<link rel="import" href="../paper-material/paper-material.html">
<link rel="import" href="../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../iron-media-query/iron-media-query.html">
<link rel="import" href="../neon-animation/neon-animation.html">
<link rel="import" href="../iron-image/iron-image.html">
<link rel="import" href="../paper-radio-group/paper-radio-group.html">
<link rel="import" href="../paper-menu/paper-menu.html">
<link rel="import" href="../iron-icons/iron-icons.html">
<!-- link rel="import" href="ir-gallery-style.html" -->

<script rel="import" src="../iscroll/build/iscroll.js"></script>
<script src="../css-element-queries/src/ResizeSensor.js"></script>

<dom-module id="ir-gallery">
	<style> 
		:host {
			overflow : hidden
		}
		
		#contentWrapper { display : none }
		
		.viewPort {
			height :600px;
			width : 400px;
			overflow : hidden;
			margin : 0;
			padding : 0;
			background : transparent;
		}

		.wrapper {
			position: relative;

			overflow: hidden;

			/* Prevent native touch events on Windows */
			-ms-touch-action: none;

			/* Prevent the callout on tap-hold and text selection */
			-webkit-touch-callout: none;
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;

			/* Prevent text resize on orientation change, useful for web-apps */
			-webkit-text-size-adjust: none;
			-moz-text-size-adjust: none;
			-ms-text-size-adjust: none;
			-o-text-size-adjust: none;
			text-size-adjust: none;
		}
		
		.wrapper.main,.main {
			width: 100%;
			height : 500px;
			padding : 0;
		}
		.wrapper.thumbnails, .thumbnails {
			padding : 0;
		}
		
		.thumbnails {
			cursor : pointer
		}

		.main iron-image {
			width : 200px
		}
		.scroller iron-image {
			width : 200px
		}
		
		.scroller {
			abackground-color : #ddee00;
			position: absolute;

			/* Prevent elements to be highlighted on tap */
			-webkit-tap-highlight-color: rgba(0,0,0,0);

			/* Put the scroller into the HW Compositing layer right from the start */
			-webkit-transform: translateZ(0);
			-moz-transform: translateZ(0);
			-ms-transform: translateZ(0);
			-o-transform: translateZ(0);
			transform: translateZ(0);
			
			/*width : 600px;
			height : 200px;*/
		
			display : flex;
			left : 0;
		}
		
		figure {
			margin : 0 auto auto;
		}
		figcaption {
		}		

		.slide {
			/*float: left;*/
			/*border : 1px solid red;*/
			@apply(--slide-mixin)
		}
		
		paper-dialog {
			background : transparent;
			overflow : hidden;
			position : fixed;
			left : 0;
			top : 0;
			bottom : 0;
			right 0;
		}
		
		.wrapper {
		}
	</style>
	<template>
		<div id="container">
			<div class="viewPort" id="inlineContainer"></div>
			<paper-dialog id="dialog" on-iron-overlay-opened='openedDialog' with-backdrop><div class="viewPort" id="dialogContainer"></div></paper-dialog>
			<div id="contentWrapper"><content id="contentNode"></content></div>
		</div>
	</template>

</dom-module>


<dom-module id="ir-gallery-echo-html">

  <template>
	<span id="content"></span>
  </template>

  <script>
	Polymer({
	  is: 'ir-gallery-echo-html',
	  properties: {
		  html: {
			  type: String,
			  value: '',
			  observer : 'htmlChanged'
		  }
	  },
		htmlChanged: function() {
		this.$.content.innerHTML = this.html;
		  //this.innerHTML = this.html;
	  }
	});
  </script>

</dom-module>

<dom-module id="ir-gallery-theme">
	<template>
	  <content id="templates"></content>
	</template>
</dom-module>

<script>
(function() {
  "use strict";

  var themes  = {};

  Polymer({
	is : "ir-gallery-theme",

	properties : {
	  templateItem :  { type : Object, notify : true },
	  name :		  { type : String, notify : true }
	},

	behaviors : [
	  Polymer.Templatizer
	],

	attached : function() {

	  var templates = Polymer.dom(this.$.templates).getDistributedNodes(),
		  inlineTemplate,
		  dialogTemplate;
	  	  
	  for(var i = 0; i < templates.length; i++)
		if(templates[i].tagName == "TEMPLATE")
		  if(templates[i].hasAttribute('inline'))
			inlineTemplate = templates[i];
		  else
			if(templates[i].hasAttribute('dialog'))
			  dialogTemplate = templates[i];   

	  inlineTemplate.className = "";
	  dialogTemplate.className = "";

	  themes[this.name] = { inline : inlineTemplate, dialog : dialogTemplate, name : this.name };

	  this.fire('ir-gallery-theme-ready', { inline : inlineTemplate, dialog : dialogTemplate, name : this.name });
	}
  });
  
  function dimensionsData() {
	return {
		width : 0,
		height : 0
	}
  }
  
  function displayAreaData(areaName, sectionName) {
	return {
				name : areaName,
				section : sectionName,
				slides : [],
				captions : [],
				scroller : null,
				wrapper : null,
				dimensions : {
					wrapper : dimensionsData(),
					slide : dimensionsData(),
					scroller : dimensionsData(),
				}
			}
  }
  
  function sectionData(sectioName) {
	return {
		name : sectioName,
		template : null,
		dirty : { images : true, size : true },
		dimensions : dimensionsData(),
		displayAreas : {
			main 		: displayAreaData('main', sectioName),
			thumbnails 	: displayAreaData('thumbnails', sectioName),
		}
	}
  }
  
  function sectionsDataStore() {
	return {
		inline : sectionData('inline'),
		dialog : sectionData('dialog')
	}
  }
  
  Polymer({
			is : 'ir-gallery',

			properties : {
				theme 			:	{ type : String, notify : true, value : "default" },
				themeWaitTime   :   { type : Number, value : 5000 },
				currentPage 	: 	{ type : Number, value : 0 },
				ratio 			: 	{ type : Number, value : .8 },
				themes 			: 	{ type : Object, value : themes },
				images  		: 	{ type : Array, value : function() { return [] } },
				sectionsData 	: 	{ type : Object, value : sectionsDataStore }
			},
			
			behaviors : [
				Polymer.Templatizer
			],

			ready : function () {
			},
			
			attached : function () {
				//this.scanForImages();

				this._observeLocalDom();
				
				//return;
				//this.showSection('inline', function() {
				//	this.async(function() {
						// observe resize
						new ResizeSensor(this.offsetParent, function() {
							this.debounce('ResizeSensor', function() { 
								this.setDirty('size')
								this.showSection(); 
							}, 300);
						}.bind(this))
				//	}, 300);
				//}.bind(this));
			},
			
			_observeLocalDom : function() {
				// observe nodes
				
				this._domOberver = 
					Polymer.dom(this.$.contentNode).observeNodes(function(info) {
						if(this._muteObserver)
							return;
						this.cancelDebouncer('observeNodes');
						this.debounce('observeNodes', function() {
							this._muteObserver = true;
							this.resetAll();
							this.scanForImages();
							this.setDirty('images');
							this.showSection(null, function() {
								Polymer.dom.flush();
								this.async(function() { this._muteObserver = false; }, 500);
							}.bind(this));
						}, 300);
					}.bind(this))
			},

			observeLocalDom : function(bool) {
				this._muteObserver = bool;
				//Polymer.dom(this.$.contentNode).unobserveNodes(this._domObserver);
			},
			
			showSection : function(sectionName, callback) {
				this.forEachSection(function(sd) {
					// section not initialized or theme changed
					if(sd.theme != this.theme || sd.dirty.images)
					{
						this.resetAll(sd.name);
						
						this.applyTheme(sd.name, function() {
							this.fillAndFit(sd.name);
							this.goToPage(this.currentPage);

							if(callback)
								callback();
						}.bind(this));
					}
					if(sd.dirty.size)
						this.refit();
				}.bind(this), sectionName);
			},

			resetAll : function(sectionName) {
				this.destroyScrollers(sectionName);
				this.clearSections(sectionName);
				this.resetDimensions(sectionName);
			},
			
			// fits the section into its container and fills out images&scrollers
			fillAndFit : function(sectionName) {
				this.fitSectionContent(sectionName);
				this.fillSectionContent(sectionName);
				this.styleSectionContent(sectionName);

				this.assignCommands(this.sectionsData[sectionName].container);
			},
			
			refit : function(sectionName) {
				this.resetDimensions(sectionName);
				this.forEachSection(function(section) {
					if(!section.initialized) // not initialized
						return;
						
					this.fitSectionContent(section.name);
					this.styleSectionContent(section.name);
				}.bind(this), sectionName);
				this.forEachScroller(function(s) {
					s.refresh();
				}.bind(this), sectionName)
			},
			
			resetDimensions : function(sectionName) {
				this.forEachDisplayArea(function(da) {
					Object.keys(da.dimensions).forEach(function(type) {
						da.dimensions[type] = dimensionsData();
					}, sectionName)
				}.bind(this)); 
			},

			// styles section content in a non-destructive manner
			styleSectionContent : function(sectionName) {
				this.forEachDisplayArea(function(da) {
					var capSize, size = da.dimensions.slide;

					this.scopeSubtree(da.wrapper, true);

					da.slides.forEach(function(slideData) {
						this.setSize(slideData.slide, size);
						this.setSize(slideData.wrapper, size);

						if(!slideData.caption)
							this.setSize(slideData.image, size);
						else
						{
							this.setSize(slideData.image, { width : size.width, height : size.height * this.ratio });
							this.setSize(slideData.caption, { width : size.width, height : size.height * (1 - this.ratio) });
						}
						slideData.slide.display = 'block';
						slideData.slide.style.textAlign = 'center';
						
					}.bind(this));
				}.bind(this), sectionName);
			},

			// fills section into container or dimensions given in its css
			fillSectionContent : function fillSectionContent(sectionName) {
				this.observeLocalDom(false);

				this.forEachDisplayArea(function(da) {
				
					this.populateDisplayArea(da);
					this.populateSlides(da);
					this.upgradeScroller(da);
				
					this.clearDirty('images', da.sectionName);
				}.bind(this), sectionName); 

				this.sectionsData[sectionName].initialized = true;
				
				this.observeLocalDom(true);
			},
			
			// fits section into container or dimensions given in its css
			fitSectionContent : function fitSectionContent(sectionName) {
				var container, minh, minw, fminh, fminw, t, bcr,
					dialogMode = sectionName == 'dialog', takesh, takesw;
				
				container = this.$[sectionName + "Container"];
				
				minh = Infinity; //this.dimensions[sectionName].refit.height;
				minw = Infinity;
				
				fminh = function(val) { minh = Math.min(minh, val) || val || minh } // these help us see the trees behind the forest
				fminw = function(val) { minw = Math.min(minw, val) || val || minw }
				
				if(!dialogMode)
				{
					fminh(this.style.height && this.style.height.replace(/px/, ''));
					fminw(this.style.width && this.style.width.replace(/px/, ''));
				}
				else
				{
					if(dialogMode && this.$.dialog.opened)
						this.setSize(this.$.dialog, { width : document.body.clientWidth, height : document.body.clientHeight});
				}
				
				fminh(document.body.clientHeight);
				fminw(document.body.clientWidth);

				t = container.offsetParent;
				if(t)
					do {
						bcr = t.getBoundingClientRect();
						fminw(bcr.width);
						fminh(bcr.height)
						fminw(t.clientWidth)
						fminh(t.clientHeight)
						t = t.offsetParent;
					} while(t);
				
				this.forEachDisplayArea(function(da) {
					if(da.wrapper)
						da.wrapper.style.height = 0;
				}, sectionName);
				
				container.style.height = 0;
				container.style.width = 0;
				
				takesh = container.scrollHeight
				takesw = container.scrollWidth
			
				container.style.height = minh;
				container.style.width = minw;
				
				this.forEachDisplayArea(function(da) {
					da.wrapper.style.width = minw;
						da.dimensions.wrapper.width = minw;
					
					da.wrapper.style.height = 
						da.dimensions.wrapper.height = (minh -takesh) * (da.name == 'main' ? this.ratio : 1 - this.ratio);
				
					da.dimensions.slide.height = da.dimensions.wrapper.height;
					da.dimensions.slide.width = da.name == 'main' ? minw : da.dimensions.slide.height * (minh / minw); 
				}.bind(this), sectionName);
			},
			
			isCaptionWrapper : function isCaptionWrapper(el) {
				return el.nodeName == 'FIGURE';
			},
			
			getCaptionHTML : function getCaptionHTML(el) {
				return Polymer.dom(Polymer.dom(el).querySelector('figcaption')).innerHTML;
			},
			
			getImageCaption : function getImageCaption(img) {
				var captionHolder, captonChildren = [];
				if(this.isCaptionWrapper(img.parentNode))
					return Polymer.dom(Polymer.dom(img.parentNode).querySelector('figcaption')).innerHTML;
					
				return;
			},
			
			scanForImages : function scanForImages() {
				var imgs = Polymer.dom(this).querySelectorAll('img');
				
				this.images = [];
				
				imgs.forEach(function(img, i) {
					var imgData = 	{
										src : img.src, 
										captionHTML : this.getImageCaption(img), 
										index : i
									};
									
					this.images.push(imgData);
				}.bind(this));
			},
			
			/*
				apply theme to all initialized sections
				waits for theme to be initialized 
			*/
			applyTheme : function applyTheme(sectionName, callback) {
				var initialized, apply;
				
				apply = function() { 
					if(initialized)
						return;
					
					this.applyThemeToSection(sectionName);
					initialized = true;
					
					if(callback)
						callback();

					return;
					
					if(this.$.dialog.opened)
					{
						this.async(function() {
							this.applyThemeToSection('dialog', this.refit.bind(this, 'dialog'));
						}, 100);
					}
				}.bind(this);
				
				if(this.themes[this.theme])
					apply();
				else
				{
					document.addEventListener('ir-gallery-theme-ready', function(ev) {
						if(ev.detail.name == this.theme)
							apply(); //(themes[this.theme].inline, themes[this.theme].dialog, true);
					}.bind(this));

					// if nothing happened within themeWaitTime milliseconds the template is probably not available and we should use the default
					this.async(apply, this.themeWaitTime);
				}
			},
			
			/*
				populates theme section with the section's theme template
			*/
			applyThemeToSection : function applyThemeToSection(sectionName) {				
				this.forEachSection(function(sd) {
					var instance, section, sd;

					section = sd.container;
					
					if(sd.theme == this.theme)
						return;

					sd.container = this.$$("#" + sd.name + "Container")
					
					this.sectionsData[sd.name].template = this.themes[this.theme][sd.name]; // y?
					
					instance = this.stampThemeSection(sd.container, this.themes[this.theme][sd.name]);

					sd.displayAreas.main.wrapper = Polymer.dom(sd.container).querySelector('.main');
					sd.displayAreas.thumbnails.wrapper = Polymer.dom(sd.container).querySelector('.thumbnails');
					
					sd.theme = this.theme;
				}.bind(this), sectionName);
			},

			/* Go to next page, circular */
			nextPage : function nextPage(page) {
				var p = this.currentPage, 
					l = this.images.length - 1;
				
				p = p >= l ? 0 : p + 1; 
				this.goToPage(p);
			},

			/* Go to prev page, circular */
			prevPage : function prevPage(page) {
				if(this.images.length <= 1)
					return
				var p = this.currentPage, 
					l = this.images.length - 1;
				
				p = p <= 0 ? l : p - 1; 
				this.goToPage(p)
			},
			
			/* Go to page by number, zero-based */
			goToPage : function goToPage(page) {
				if(this.images.length <= 1)
					return
				this.currentPage = page;
				this.syncScrollers();
			},
			
			/* visit each or only one section, calls the visitor function with sectionData object for each section */
			forEachSection : function forEachSection(foo, sectionName) {
				if(!sectionName)
					sectionName = ['inline', 'dialog'];
				if(!(sectionName instanceof Array))
					sectionName = [sectionName];
					
				sectionName.forEach(function(s) { 
					foo(this.sectionsData[s]) 
				}.bind(this));
			},

			/* visit each display area, calls the visitor function with displayAreaData object for each section */
			forEachDisplayArea : function forEachDisplayArea(foo, sectionName) {
				this.forEachSection(function(s) {
					Object.keys(s.displayAreas)
						.forEach(function(da) { 
							var q = s.displayAreas[da];
							if(q) 
								foo(q); 
						}.bind(this));
				}, sectionName);
			},
			
			/* visit each scroller, calls the visitor function with iscroll object */
			forEachScroller : function forEachScroller(foo, sectionName) {
				this.forEachDisplayArea(function(da) {
					if(da.iscroll && da.scroller.clientWidth)
						foo(da.iscroll);
				}, sectionName);
			},
			
			setDirty : function setDirty(property, sectionName) {
				this.forEachSection(function(s) {
					s.dirty[property] = true;
				}, sectionName);
			},
			
			clearDirty : function clearDirty(property, sectionName) {
				this.forEachSection(function(s) {
					s.dirty[property] = false;
				}, sectionName);
			},
			
			/* destroys all iscroll objects */
			destroyScrollers : function destroyScrollers(sectionName) {
				this.forEachDisplayArea(function(da) { 
					da.scroller = null; 
					
					if(!da.iscroll)
						return;
						
					da.iscroll.destroy(); 
					da.iscroll = null; 
				}, sectionName);
			},

			/* clear both or one of the containers */
			clearSections : function clearSections(sectionName) {
				this.forEachSection(function(s) {
					if(s.container) s.container.innerHTML = '';
					s.theme = null;
				}, sectionName);
			},
			
			/* sync all scrollers to this.currentPage */
			syncScrollers : function syncScrollers() {
				this.cancelDebouncer('syncScrollers');
				this.debounce('syncScrollers', function() {
					this._syncingScrollers;
					this.forEachScroller(function(s) {
						s.goToPage(this.currentPage, 0);
						this.async(function() {
							this._syncingScrollers = false;
						}, 400);
					}.bind(this))
				}.bind(this), 200)
			},
			
			/*
				stamp theme template into section
				returns template instance (Polymer.base)
			*/
			stampThemeSection : function stampThemeSection(container, template) {
				var instance, t;
				t = template;		
				
				this.templatize(t);
				instance = this.stamp({});
				Polymer.dom(container).appendChild(instance.root);
				
				return instance;
			},
			
			/* upgrades scroller element to iscroll */
			upgradeScroller : function upgradeScroller(da, callback)
			{
				if(da.iscroll)
					return da.iscroll.refresh();

				da.wrapper.style.position = 'relative'
				da.wrapper.style.overflow = 'hidden'; 
				da.scroller.style.position = 'relative'
				da.scroller.style.width = da.dimensions.slide.width * this.images.length

				this.async( function ugradeScrollerAsync(target) {
					da.iscroll = new IScroll(da.wrapper, {
						mouseWheel: true,
						scrollX: this.images.length > 1,
						scrollY: false,
						momentum: true,
						snap: ".slide",
						snapSpeed: 300,
						keyBindings: da.name == 'dialog' && this.images.length > 1
					});
					
					this.async(function() {
						da.iscroll.refresh();
					}, 200);
					
					if(this.images.length > 1 && da.section == 'main')
						da.iscroll.on('scrollEnd', function() { 
							if(this._syncingScrollers)
								return;
							this.currentPage = da.iscroll.currentPage.pageX;
							this.syncScrollers();
						}.bind(this));
					
					if(callback) callback();
				}, 200);									
			},

			/* assign command to all selectors in target */
			assignCommand : function assignCommand(target, selector, foo, name)
			{
				var els = Polymer.dom(target).querySelectorAll(selector);
				els.forEach(function(el) {
					if(el[name])
						return;
						
					el[name] = true;
					el.addEventListener('click', foo)
				}.bind(this));
			},
			
			/* assign standard commands to marked elements in target. mark with command-forward, command-backward  */
			assignCommands : function assignCommands(target) {
				'forward->nextPage,backward->prevPage,close->closeDialog'.split(/,/).forEach(function(cd) {
					var c;
					c = cd.split(/->/);
					this.assignCommand(target, '[command-' + c[0] + ']', this[c[1]].bind(this), cd);
					target[cd] = true;
				}.bind(this));
			},

			closeDialog : function () {
				this.$.dialog.close();
			},

			openedDialog : function openedDialog() {
				var size = Math.min(document.body.clientWidth, document.body.clientHeight);
				this.setSize(this.$.dialog, size);
		
				this.$.dialog.style.width = document.body.clientWidth;
				this.$.dialog.style.height = document.body.clientHeight;
				
				this.showSection('dialog');
			},

			openDialog : function openDialog()
			{
				this.$.dialog.open();				
			},
			
			setSize : function(el, size)
			{
				if(typeof size != 'object')
					size = { height : size, width : size };
					
				el.style.width = size.width;
				el.style.height = size.height;
				
				return el;
			},
			
			// creates a slide from data. returns slideData
			slideFromData : function(imgData, opts, thumbsMode)
			{
				var wrapper, caption, tocenter, w, h, imgel, slide,
					hasCaption = imgData.captionHTML && !thumbsMode;

				imgel = document.createElement('iron-image');
				slide = document.createElement('div');
				slide.classList.add('slide');
				slide.style.position = 'relative';

				imgel.src = imgData.src;
				imgel.index = imgData.index;
				imgel.sizing = 'contain';
				imgel.style.width = opts.width
				imgel.style.height = opts.height

				wrapper = document.createElement('figure');					
				Polymer.dom(wrapper).appendChild(imgel);
				Polymer.dom(slide).appendChild(wrapper);

				if(hasCaption)
				{
					caption = document.createElement('figcaption');
					Polymer.dom(caption).innerHTML = imgData.captionHTML;				
					Polymer.dom(wrapper).appendChild(caption);
				}
				
				if(opts.onclick)
					slide.addEventListener("click", opts.onclick.bind(this));
			
				return { 
							slide : slide, 
							caption : caption, 
							wrapper : wrapper,
							image : imgel
						};
			},
			
			/* Populates slides into a display area */
			populateSlides : function(da) {
				var thumbMode = da.name == 'thumbnails';
				
				da.slides.forEach(function(slideData) {
					Polymer.dom(Polymer.dom(slideData.slide).parentNode).removeChild(slideData.slide);
				});
				
				da.slides = [];
				
				// add slides to scroller
				this.images.forEach(function(imgData, index) {
					var slideData = this.slideFromData(imgData, da.dimensions[thumbMode ? 'wrapper' : 'slide'], thumbMode);
					da.slides.push(slideData);
					
					slideData.slide.addEventListener('click', function() {
						if(thumbMode)
							this.goToPage(index);
						else
						if(da.section != 'dialog')
							this.openDialog();
					}.bind(this));
					
					Polymer.dom(da.scroller).appendChild(slideData.slide);
				}.bind(this));				
			},
						
			// populates a scroller/thumbnails container
			//
			// opts: selector, size, noCaption, onClick
			populateDisplayArea : function(da) {
				var scroller, pt, thumbMode;

				// build scroller
				
				// remember: wrapper -> scroller -> slides, and iScroll is initialized on wrapper
				Polymer.dom(da.wrapper).classList.add('wrapper');
				
				// create wrapper in scroller
				scroller = document.createElement('div');
				Polymer.dom(scroller).classList.add('scroller')

				Polymer.dom(da.wrapper).appendChild(scroller);

				scroller.style.width = da.dimensions.slide.width * da.slides.length; 
				scroller.style.height = da.dimensions.slide.height; 
				da.wrapper.style.position = 'relative'; 
				da.wrapper.style.overflow = 'hidden'; 
			
				da.scroller = scroller;
			
				Polymer.updateStyles();
			}			
		});
})();		
</script>
	


<dom-module id="ir-gallery-theme-defaults">
	<template>

	<!--textarea style="display : none;"-->
	  <ir-gallery-theme name="default"> 
		<template inline> 
			<style> 
				.main { display: flex; flex: 1; padding : 5px }
				.commands { display: flex; justify-content : space-between;}
				.slide { 
					border : 3px solid green;
				}
				.thumbnails { display : flex, align-items : middle}
				#inline-wrapper { background : #fafafa;  background : pink; margin-bottom : 2px }
			</style>
			<div id="inline-wrapper">
				<div class="main"></div> 
				<div class="commands"><paper-icon-button command-backward icon="chevron-left"></paper-icon-button><paper-icon-button command-forward icon="chevron-right"></paper-icon-button></div>
				<div class="thumbnails"></div>
			</div>
		</template> 
		<template dialog> 
		  <style>
			.main > * {
				display : block;
				border-style: solid; 
				border-radius: 8px; 
				border-color: #767676; 
				border-width: 4px; 
				box-shadow: 0 0 0 0; 
				padding : 10px;
				background : white;
			}
			.figure {
				display : flex;
				align-items: center;
				justify-content: center;
			}
			.canceldiv { text-align : right }
			#dialog-wrapper { position : relative; background : white; border : 3px grey solid; border-radius : 5px; }

		   </style> 
		  <div id="dialog-wrapper"> 
			<div class="main"></div>
			<div class="commands"><paper-icon-button command-backward icon="chevron-left"></paper-icon-button><paper-icon-button command-forward icon="chevron-right"></paper-icon-button></div>
			<div class="thumbnails"></div>
			<div class='canceldiv'><paper-icon-button command-close icon="cancel"></paper-icon-button></div>
		  </div> 
		</template>
	  </ir-gallery-theme> 
	  <ir-gallery-theme name="transparent"> 
		<template inline> 
		  <style>
			.main { display: flex; flex: 1;}
		  </style> 
		  <div class="main"></div> 
		  <div class="scroller"></div> 
		</template> 
		<template dialog> 
		  <style>
			.transparentBlock {display: flex; flex: 1; flex-direction: column;} .dmain { display: flex; flex: 1;}
		  </style>
		  <div class="transparentBlock"> 
			<div class="dmain"></div> 
			<div class="dscroller"></div> 
			<div style="text-align: right;"> 
			  <paper-icon-button id="cancelButton" icon="cancel"></paper-icon-button> 
			</div>
		  </div> 
		</template>
	  </ir-gallery-theme>
	<!--/textarea-->
  		
	</template>
</dom-module>


<script>
(function() {
  Polymer({
		is : "ir-gallery-theme-defaults",

		attached : function(e) {
			var templates = document.createElement('div');
			//templates.innerHTML = Polymer.dom(this.root).innerHTML;
			Polymer.dom(document.body).appendChild(this.root);
		}
	})

	// This might not suffice for some browsers but seems like everything after IE8 is fine.
	document.addEventListener("DOMContentLoaded", function() {
		Polymer.dom(document.body).appendChild(document.createElement("ir-gallery-theme-defaults"));
	});
  

})();
</script>